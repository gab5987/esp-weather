\chapter{Unity Test API}
\hypertarget{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e}{}\label{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e}\index{Unity Test API@{Unity Test API}}
\href{https://travis-ci.org/ThrowTheSwitch/Unity}{\texttt{ }} {\bfseries{Copyright (c) 2007 -\/ 2017 Unity Project by Mike Karlesky, Mark Vander\+Voord, and Greg Williams}}\hypertarget{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md370}{}\doxysection{\texorpdfstring{Running Tests}{Running Tests}}\label{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md370}
\begin{DoxyVerb}RUN_TEST(func, linenum)
\end{DoxyVerb}
 Each Test is run within the macro {\ttfamily RUN\+\_\+\+TEST}. This macro performs necessary setup before the test is called and handles cleanup and result tabulation afterwards.\hypertarget{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md371}{}\doxysection{\texorpdfstring{Ignoring Tests}{Ignoring Tests}}\label{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md371}
There are times when a test is incomplete or not valid for some reason. At these times, TEST\+\_\+\+IGNORE can be called. Control will immediately be returned to the caller of the test, and no failures will be returned. \begin{DoxyVerb}TEST_IGNORE()
\end{DoxyVerb}
 Ignore this test and return immediately \begin{DoxyVerb}TEST_IGNORE_MESSAGE (message)
\end{DoxyVerb}
 Ignore this test and return immediately. Output a message stating why the test was ignored.\hypertarget{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md372}{}\doxysection{\texorpdfstring{Aborting Tests}{Aborting Tests}}\label{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md372}
There are times when a test will contain an infinite loop on error conditions, or there may be reason to escape from the test early without executing the rest of the test. A pair of macros support this functionality in Unity. The first {\ttfamily TEST\+\_\+\+PROTECT} sets up the feature, and handles emergency abort cases. {\ttfamily TEST\+\_\+\+ABORT} can then be used at any time within the tests to return to the last {\ttfamily TEST\+\_\+\+PROTECT} call. \begin{DoxyVerb}TEST_PROTECT()
\end{DoxyVerb}
 Setup and Catch macro \begin{DoxyVerb}TEST_ABORT()
\end{DoxyVerb}
 Abort Test macro

Example\+: \begin{DoxyVerb}main()
{
    if (TEST_PROTECT())
    {
        MyTest();
    }
}
\end{DoxyVerb}
 If My\+Test calls {\ttfamily TEST\+\_\+\+ABORT}, program control will immediately return to {\ttfamily TEST\+\_\+\+PROTECT} with a return value of zero.\hypertarget{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md373}{}\doxysection{\texorpdfstring{Unity Assertion Summary}{Unity Assertion Summary}}\label{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md373}
\hypertarget{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md374}{}\doxysubsection{\texorpdfstring{Basic Validity Tests}{Basic Validity Tests}}\label{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md374}
\begin{DoxyVerb}TEST_ASSERT_TRUE(condition)
\end{DoxyVerb}
 Evaluates whatever code is in condition and fails if it evaluates to false \begin{DoxyVerb}TEST_ASSERT_FALSE(condition)
\end{DoxyVerb}
 Evaluates whatever code is in condition and fails if it evaluates to true \begin{DoxyVerb}TEST_ASSERT(condition)
\end{DoxyVerb}
 Another way of calling {\ttfamily TEST\+\_\+\+ASSERT\+\_\+\+TRUE} \begin{DoxyVerb}TEST_ASSERT_UNLESS(condition)
\end{DoxyVerb}
 Another way of calling {\ttfamily TEST\+\_\+\+ASSERT\+\_\+\+FALSE} \begin{DoxyVerb}TEST_FAIL()
TEST_FAIL_MESSAGE(message)
\end{DoxyVerb}
 This test is automatically marked as a failure. The message is output stating why.\hypertarget{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md375}{}\doxysubsection{\texorpdfstring{Numerical Assertions\+: Integers}{Numerical Assertions: Integers}}\label{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md375}
\begin{DoxyVerb}TEST_ASSERT_EQUAL_INT(expected, actual)
TEST_ASSERT_EQUAL_INT8(expected, actual)
TEST_ASSERT_EQUAL_INT16(expected, actual)
TEST_ASSERT_EQUAL_INT32(expected, actual)
TEST_ASSERT_EQUAL_INT64(expected, actual)
\end{DoxyVerb}
 Compare two integers for equality and display errors as signed integers. A cast will be performed to your natural integer size so often this can just be used. When you need to specify the exact size, like when comparing arrays, you can use a specific version\+: \begin{DoxyVerb}TEST_ASSERT_EQUAL_UINT(expected, actual)
TEST_ASSERT_EQUAL_UINT8(expected, actual)
TEST_ASSERT_EQUAL_UINT16(expected, actual)
TEST_ASSERT_EQUAL_UINT32(expected, actual)
TEST_ASSERT_EQUAL_UINT64(expected, actual)
\end{DoxyVerb}
 Compare two integers for equality and display errors as unsigned integers. Like INT, there are variants for different sizes also. \begin{DoxyVerb}TEST_ASSERT_EQUAL_HEX(expected, actual)
TEST_ASSERT_EQUAL_HEX8(expected, actual)
TEST_ASSERT_EQUAL_HEX16(expected, actual)
TEST_ASSERT_EQUAL_HEX32(expected, actual)
TEST_ASSERT_EQUAL_HEX64(expected, actual)
\end{DoxyVerb}
 Compares two integers for equality and display errors as hexadecimal. Like the other integer comparisons, you can specify the size... here the size will also effect how many nibbles are shown (for example, {\ttfamily HEX16} will show 4 nibbles). \begin{DoxyVerb}TEST_ASSERT_EQUAL(expected, actual)
\end{DoxyVerb}
 Another way of calling TEST\+\_\+\+ASSERT\+\_\+\+EQUAL\+\_\+\+INT \begin{DoxyVerb}TEST_ASSERT_INT_WITHIN(delta, expected, actual)
\end{DoxyVerb}
 Asserts that the actual value is within plus or minus delta of the expected value. This also comes in size specific variants.

\begin{DoxyVerb}TEST_ASSERT_GREATER_THAN(threshold, actual)
\end{DoxyVerb}
 Asserts that the actual value is greater than the threshold. This also comes in size specific variants.

\begin{DoxyVerb}TEST_ASSERT_LESS_THAN(threshold, actual)
\end{DoxyVerb}
 Asserts that the actual value is less than the threshold. This also comes in size specific variants.\hypertarget{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md376}{}\doxysubsection{\texorpdfstring{Arrays}{Arrays}}\label{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md376}
\begin{DoxyVerb}_ARRAY
\end{DoxyVerb}
 You can append {\ttfamily \+\_\+\+ARRAY} to any of these macros to make an array comparison of that type. Here you will need to care a bit more about the actual size of the value being checked. You will also specify an additional argument which is the number of elements to compare. For example\+: \begin{DoxyVerb}TEST_ASSERT_EQUAL_HEX8_ARRAY(expected, actual, elements)

_EACH_EQUAL
\end{DoxyVerb}
 Another array comparison option is to check that EVERY element of an array is equal to a single expected value. You do this by specifying the EACH\+\_\+\+EQUAL macro. For example\+: \begin{DoxyVerb}TEST_ASSERT_EACH_EQUAL_INT32(expected, actual, elements)
\end{DoxyVerb}
 \hypertarget{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md377}{}\doxysubsection{\texorpdfstring{Numerical Assertions\+: Bitwise}{Numerical Assertions: Bitwise}}\label{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md377}
\begin{DoxyVerb}TEST_ASSERT_BITS(mask, expected, actual)
\end{DoxyVerb}
 Use an integer mask to specify which bits should be compared between two other integers. High bits in the mask are compared, low bits ignored. \begin{DoxyVerb}TEST_ASSERT_BITS_HIGH(mask, actual)
\end{DoxyVerb}
 Use an integer mask to specify which bits should be inspected to determine if they are all set high. High bits in the mask are compared, low bits ignored. \begin{DoxyVerb}TEST_ASSERT_BITS_LOW(mask, actual)
\end{DoxyVerb}
 Use an integer mask to specify which bits should be inspected to determine if they are all set low. High bits in the mask are compared, low bits ignored. \begin{DoxyVerb}TEST_ASSERT_BIT_HIGH(bit, actual)
\end{DoxyVerb}
 Test a single bit and verify that it is high. The bit is specified 0-\/31 for a 32-\/bit integer. \begin{DoxyVerb}TEST_ASSERT_BIT_LOW(bit, actual)
\end{DoxyVerb}
 Test a single bit and verify that it is low. The bit is specified 0-\/31 for a 32-\/bit integer.\hypertarget{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md378}{}\doxysubsection{\texorpdfstring{Numerical Assertions\+: Floats}{Numerical Assertions: Floats}}\label{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md378}
\begin{DoxyVerb}TEST_ASSERT_FLOAT_WITHIN(delta, expected, actual)
\end{DoxyVerb}
 Asserts that the actual value is within plus or minus delta of the expected value. \begin{DoxyVerb}TEST_ASSERT_EQUAL_FLOAT(expected, actual)
TEST_ASSERT_EQUAL_DOUBLE(expected, actual)
\end{DoxyVerb}
 Asserts that two floating point values are \"{}equal\"{} within a small \% delta of the expected value.\hypertarget{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md379}{}\doxysubsection{\texorpdfstring{String Assertions}{String Assertions}}\label{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md379}
\begin{DoxyVerb}TEST_ASSERT_EQUAL_STRING(expected, actual)
\end{DoxyVerb}
 Compare two null-\/terminate strings. Fail if any character is different or if the lengths are different. \begin{DoxyVerb}TEST_ASSERT_EQUAL_STRING_LEN(expected, actual, len)
\end{DoxyVerb}
 Compare two strings. Fail if any character is different, stop comparing after len characters. \begin{DoxyVerb}TEST_ASSERT_EQUAL_STRING_MESSAGE(expected, actual, message)
\end{DoxyVerb}
 Compare two null-\/terminate strings. Fail if any character is different or if the lengths are different. Output a custom message on failure. \begin{DoxyVerb}TEST_ASSERT_EQUAL_STRING_LEN_MESSAGE(expected, actual, len, message)
\end{DoxyVerb}
 Compare two strings. Fail if any character is different, stop comparing after len characters. Output a custom message on failure.\hypertarget{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md380}{}\doxysubsection{\texorpdfstring{Pointer Assertions}{Pointer Assertions}}\label{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md380}
Most pointer operations can be performed by simply using the integer comparisons above. However, a couple of special cases are added for clarity. \begin{DoxyVerb}TEST_ASSERT_NULL(pointer)
\end{DoxyVerb}
 Fails if the pointer is not equal to NULL \begin{DoxyVerb}TEST_ASSERT_NOT_NULL(pointer)
\end{DoxyVerb}
 Fails if the pointer is equal to NULL\hypertarget{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md381}{}\doxysubsection{\texorpdfstring{Memory Assertions}{Memory Assertions}}\label{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md381}
\begin{DoxyVerb}TEST_ASSERT_EQUAL_MEMORY(expected, actual, len)
\end{DoxyVerb}
 Compare two blocks of memory. This is a good generic assertion for types that can\textquotesingle{}t be coerced into acting like standard types... but since it\textquotesingle{}s a memory compare, you have to be careful that your data types are packed.\hypertarget{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md382}{}\doxysubsection{\texorpdfstring{\+\_\+\+MESSAGE}{\_MESSAGE}}\label{md_lib_2c_j_s_o_n_2tests_2unity_2_r_e_a_d_m_e_autotoc_md382}
you can append \+\_\+\+MESSAGE to any of the macros to make them take an additional argument. This argument is a string that will be printed at the end of the failure strings. This is useful for specifying more information about the problem. 